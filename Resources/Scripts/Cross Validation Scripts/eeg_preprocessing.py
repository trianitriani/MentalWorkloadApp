import numpy as np
import pywt
from scipy.signal import convolve


# Coefficients for Savitzky-Golay, the same values used in the kotlin script (127 values)
SG_COEFFS = np.array([
    -0.0841750841750842, -0.0805860805860806, -0.0770570770570771, -0.0735880735880736, -0.0701790701790702,
    -0.0668300668300668, -0.0635410635410635, -0.0603120603120603, -0.0571430571430571, -0.0540340540340540,
    -0.0509850509850510, -0.0479960479960480, -0.0450670450670451, -0.0421980421980422, -0.0393890393890394,
    -0.0366400366400366, -0.0339510339510340, -0.0313220313220313, -0.0287530287530288, -0.0262440262440262,
    -0.0237950237950238, -0.0214060214060214, -0.0190770190770191, -0.0168080168080168, -0.0145990145990146,
    -0.0124500124500124, -0.0103610103610104, -0.0083320083320083, -0.0063630063630064, -0.0044540044540045,
    -0.0026050026050026, -0.0008160008160008,  0.0009130009130009,  0.0025810025810026,  0.0041890041890042,
    0.0057370057370057,  0.0072250072250072,  0.0086530086530087,  0.0100210100210100,  0.0113290113290113,
    0.0125770125770126,  0.0137650137650138,  0.0148930148930149,  0.0159610159610160,  0.0169690169690170,
    0.0179170179170179,  0.0188050188050188,  0.0196330196330196,  0.0204010204010204,  0.0211090211090211,
    0.0217570217570218,  0.0223450223450223,  0.0228730228730229,  0.0233410233410233,  0.0237490237490238,
    0.0240970240970241,  0.0243850243850244,  0.0246130246130246,  0.0247810247810248,  0.0248890248890249,
    0.0249370249370249,  0.0249250249250249,  0.0248530248530249,  0.0247210247210247,  0.0245290245290245,
    0.0242770242770243,  0.0239650239650240,  0.0235930235930236,  0.0231610231610232,  0.0226690226690227,
    0.0221170221170221,  0.0215050215050215,  0.0208330208330208,  0.0201010201010201,  0.0193090193090193,
    0.0184570184570185,  0.0175450175450175,  0.0165730165730166,  0.0155410155410155,  0.0144490144490145,
    0.0132970132970133,  0.0120850120850121,  0.0108130108130108,  0.0094810094810095,  0.0080890080890081,
    0.0066370066370066,  0.0051250051250051,  0.0035530035530036,  0.0019210019210019,  0.0002290002290002,
    -0.0015220015220015, -0.0033320033320033, -0.0052010052010052, -0.0071290071290071, -0.0091160091160091,
    -0.0111620111620112, -0.0132670132670133, -0.0154310154310154, -0.0176540176540177, -0.0199360199360199,
    -0.0222770222770223, -0.0246770246770247, -0.0271360271360271, -0.0296540296540297, -0.0322310322310322,
    -0.0348670348670349, -0.0375620375620376, -0.0403160403160403, -0.0431290431290431, -0.0460010460010460,
    -0.0489320489320489, -0.0519220519220519, -0.0549710549710550, -0.0580790580790581, -0.0612460612460612,
    -0.0644720644720645, -0.0677570677570678, -0.0711010711010711, -0.0745040745040745, -0.0779660779660780,
    -0.0814870814870815, -0.0850670850670851
])


def savitzky_golay_filter(signal):
    return convolve(signal, SG_COEFFS, mode='same')


def soft_threshold(data, threshold):
    return np.sign(data) * np.minimum(np.abs(data), threshold)


def threshold_wavelet(signal, wavelet_name="db2"):
    coeffs = pywt.wavedec(signal, wavelet_name, level=4)
    if len(coeffs) < 5:
        raise ValueError("Insufficient wavelet components")

    # coeffs = [cA4, cD4, cD3, cD2, cD1]
    t = np.std(coeffs[2]) * 0.8  # Threshold on cD3

    thresholded = [soft_threshold(c, t) for c in coeffs]
    return pywt.waverec(thresholded, wavelet_name)


def preprocess_channel(signal):
    detrended = signal - savitzky_golay_filter(signal)
    thresholded = threshold_wavelet(detrended)
    return thresholded[:len(signal)]  # Trim to original size


def preprocess_matrix(matrix):
    return np.array([preprocess_channel(ch) for ch in matrix])
